#pragma config(Sensor, S1,     trace1,         sensorLightInactive)
#pragma config(Sensor, S2,     trace2,         sensorLightInactive)
#pragma config(Sensor, S3,     col,            sensorColorNxtFULL)
#pragma config(Motor,  motorB,           ,             tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define limit 50
int  up_light, down_light, ball;

void move();
void sense();

task main()
{
	move();
	sense();
	move();
}

void move()
{
	while(1)
  {
   up_light=SensorValue(trace1 );
   down_light=SensorValue( trace2 );

   if(SensorValue[col]==2||SensorValue[col]==5)
     break;

   if(up_light > limit)
   {
     if(down_light>limit)
     {
        motor[motorA]=30;
        motor[motorB]=30;
     }
     else
     {
       motor[motorA]=30;
       motor[motorB]=0;
       wait1Msec(500);
       for( ; ; )
       {
        	motor[motorA]=0;
          motor[motorB]=30;
          wait1Msec(1000);
          if(down_light > limit)
          	break;
       }
      	 motor[motorA]=0;
      	 motor[motorB]=0;
      	 wait1Msec(500);
      	 motor[motorA] = 30;
      	 motor[motorB] = 30;
			}
  	}
  	else
  	{
  	  if(down_light>limit)
  	  {
  	    motor[motorA]=30;
  	    motor[motorB]=0;
  	    wait1Msec(500);
      	for( ; ; )
      	{
      		motor[motorA]=0;
      	  motor[motorB]=30;
      	  wait1Msec(1000);
      	  if(down_light > limit)
      	  	break;
     	 }
     	 motor[motorA]=0;
    	 motor[motorB]=0;
       wait1Msec(500);
    	 motor[motorA] = 30;
       motor[motorB] = 30;
   	 }
     else
     {
      motor[motorA]=0;
      motor[motorB]=0;
     }
   }
 }
}

void sense()
{
	ball = SensorValue[col];

  nMotorEncoder[motorC] = 0;
  motor[motorC] = 33;
  while(nMotorEncoder[motorC] < 60){}
  motor[motorC] = 0;
  wait1Msec(50);

  motor[motorB] =-40;
  motor[motorA] = -40;
  wait1Msec(3000);

/*공을 인식하고 좌 또는 우회전 떨어트리고 시작지점까지*/
  if(ball==2)
  {
   	nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorB] =30;
    motor[motorA] = -30;
    while(nMotorEncoder[motorB] < 1200){}
    while(nMotorEncoder[motorA] > -1200){}
    motor[motorB] = 0;
    motor[motorA] = 0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorA]=-30;
    motor[motorB]=-30;
    while(nMotorEncoder[motorB] > -700){}
    while(nMotorEncoder[motorA] > -700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorC] = 0;
    motor[motorC] = 20;
    while(nMotorEncoder[motorC] < 70){}
    motor[motorC] = 0;
    wait1Msec(1000);

    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorA]=30;
    motor[motorB]=30;
    while(nMotorEncoder[motorB] < 700){}
    while(nMotorEncoder[motorA] < 700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorB] =-30;
    motor[motorA] = 30;
    while(nMotorEncoder[motorB] > -1200){}
    while(nMotorEncoder[motorA] < 1200){}
    motor[motorB] = 0;
    motor[motorA] = 0;
    wait1Msec(500);
  }


    else if(ball==5)
    {
     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] = -30;
     motor[motorA] = 30;
     while(nMotorEncoder[motorB] > -1250){}
     while(nMotorEncoder[motorA] < 1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=30;
    motor[motorB]=30;
    while(nMotorEncoder[motorB] < 700){}
     while(nMotorEncoder[motorA] < 700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

     nMotorEncoder[motorC] = 0;
     motor[motorC] = 20;
     while(nMotorEncoder[motorC] < 70){}
     motor[motorC] = 0;
     wait1Msec(1000);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=-30;
    motor[motorB]=-30;
    while(nMotorEncoder[motorB] > -700){}
     while(nMotorEncoder[motorA] > -700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] = 30;
     motor[motorA] = -30;
     while(nMotorEncoder[motorB] < 1250){}
     while(nMotorEncoder[motorA] > -1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);
   }

   /*드는 부분 내리기*/

   nMotorEncoder[motorC] = 0;
   motor[motorC] = -20;
   while(nMotorEncoder[motorC] > -100 ){}
   motor[motorC] = 0;
   wait1Msec(1000);
}
/*조금 더  앞으로 그리고 왼쪽턴*/

  nMotorEncoder[motorB] = 0;
   nMotorEncoder[motorA] = 0;
   motor[motorA]=30;
  motor[motorB]=30;
  while(nMotorEncoder[motorB] < 290){}
   while(nMotorEncoder[motorA] < 290){}
  motor[motorA]=0;
  motor[motorB]=0;
  wait1Msec(500);

  while(1)
  {
      up_light=SensorValue[trace1];

     motor[motorA]=-30;
    motor[motorB]=30;

   if(up_light<50)
   {
     break;
   }
  }


/*턴 후 다시 라인트래싱후 올리기*/

 while(1)
 {
  up_light=SensorValue(trace1 );
  down_light=SensorValue( trace2 );

  if(SensorValue[col]==2||SensorValue[col]==5)
    break;

  if(up_light > limit)
  {
    if(down_light>limit)
    {
      motor[motorA]=30;
      motor[motorB]=30;
    }
    else
    {
      motor[motorA]=30;
      motor[motorB]=0;
    }
  }
  else
  {
    if(down_light>limit)
    {
      motor[motorA]=0;
      motor[motorB]=30;
    }
    else
    {
      motor[motorA]=0;
      motor[motorB]=0;
    }
  }
}

  ball = SensorValue[col];

  nMotorEncoder[motorC] = 0;
   motor[motorC] = 33;
   while(nMotorEncoder[motorC] < 60){}
   motor[motorC] = 0;
   wait1Msec(50);


 /*후진후 턴*/

   nMotorEncoder[motorB] = 0;
   nMotorEncoder[motorA] = 0;
   motor[motorA]=-30;
  motor[motorB]=-30;
  while(nMotorEncoder[motorB] > -700){}
   while(nMotorEncoder[motorA] > -700){}

   nMotorEncoder[motorB] = 0;
   nMotorEncoder[motorA] = 0;
   motor[motorB] = -30;
   motor[motorA] = 30;
   while(nMotorEncoder[motorB] > -1250){}
   while(nMotorEncoder[motorA] < 1250){}
   motor[motorB] =0;
   motor[motorA] =0;
   wait1Msec(500);


/*후진 후 앞으로 살??? 전진*/

   motor[motorB] =-40;
   motor[motorA] = -40;
   wait1Msec(3000);

   motor[motorB] =20;
   motor[motorA] =20;
   wait1Msec(500);

 /*공을 인식하고 좌 또는 우회전 떨어트리고 시작지점까지*/

   if(ball==2)
  {

    nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] =30;
     motor[motorA] = -30;
     while(nMotorEncoder[motorB] < 1250){}
     while(nMotorEncoder[motorA] > -1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=30;
    motor[motorB]=30;
    while(nMotorEncoder[motorB] < 700){}
     while(nMotorEncoder[motorA] < 700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

     nMotorEncoder[motorC] = 0;
     motor[motorC] = 20;
     while(nMotorEncoder[motorC] < 70){}
     motor[motorC] = 0;
     wait1Msec(1000);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=-30;
    motor[motorB]=-30;
    while(nMotorEncoder[motorB] > -700){}
     while(nMotorEncoder[motorA] > -700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] =-30;
     motor[motorA] = 30;
     while(nMotorEncoder[motorB] > -1250){}
     while(nMotorEncoder[motorA] < 1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);

     }


    else if(ball==5)
    {
     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] = -30;
     motor[motorA] = 30;
     while(nMotorEncoder[motorB] > -1250){}
     while(nMotorEncoder[motorA] < 1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=30;
    motor[motorB]=30;
    while(nMotorEncoder[motorB] < 700){}
     while(nMotorEncoder[motorA] < 700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

     nMotorEncoder[motorC] = 0;
     motor[motorC] = 20;
     while(nMotorEncoder[motorC] < 70){}
     motor[motorC] = 0;
     wait1Msec(1000);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=-30;
    motor[motorB]=-30;
    while(nMotorEncoder[motorB] > -700){}
     while(nMotorEncoder[motorA] > -700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] = 30;
     motor[motorA] = -30;
     while(nMotorEncoder[motorB] < 1250){}
     while(nMotorEncoder[motorA] > -1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);
   }
