#pragma config(Sensor, S1,     trace1,         sensorLightInactive)
#pragma config(Sensor, S2,     trace2,         sensorLightInactive)
#pragma config(Sensor, S3,     col,            sensorColorNxtFULL)
#pragma config(Motor,  motorB,           ,             tmotorNXT, PIDControl, reversed, encoder)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#define limit 50

void move();
void sense();

int up_light, down_light, ball;

task main()
{
	move();
	sense();
}

void move()
{
	up_light = SensorValue(trace1);
	down_light = SensorValue(trace2);

	while(1)
	{
	if(SensorValue[col]==2||SensorValue[col]==5)
     break;

   if(up_light > limit)
   {
     if(down_light>limit)
     {
        motor[motorA]=30;
        motor[motorB]=30;
     }
     else
     {
       motor[motorA]=30;
       motor[motorB]=0;
       wait1Msec(500);
       for(int i=1; ;i++)
       {
        	motor[motorA]=0;
          motor[motorB]=30;
          wait1Msec(500+(i*100));
        	motor[motorA]=30;
          motor[motorB]=0;
          wait1Msec(500+((i+1)*100));
          if(down_light > limit)
          	break;
       }
       motor[motorA]=0;
       motor[motorB]=0;
       wait1Msec(500);
     	 motor[motorA] = 30;
     	 motor[motorB] = 30;
		}
 	}
 	else
 	{
  	  if(down_light>limit)
  	  {
  	   motor[motorA]=30;
       motor[motorB]=0;
       wait1Msec(500);
       for(int i=1; ;i++)
       {
        	motor[motorA]=0;
          motor[motorB]=30;
          wait1Msec(500+(i*100));
        	motor[motorA]=30;
          motor[motorB]=0;
          wait1Msec(500+((i+1)*100));
          if(up_light > limit)
          	break;
       }
     	 motor[motorA]=0;
    	 motor[motorB]=0;
       wait1Msec(500);
    	 motor[motorA] = 30;
       motor[motorB] = 30;
   	 }
     else
     {
       for(int i=1; ;i++)
       {
        	motor[motorA]=0;
          motor[motorB]=30;
          wait1Msec(500+(i*100));
        	motor[motorA]=30;
          motor[motorB]=0;
          wait1Msec(500+((i+1)*100));
          if(up_light > limit)
          	break;
       }
     }
   }
 }
}

void sense()
{
	ball = SensorValue[col];

  nMotorEncoder[motorC] = 0;
  motor[motorC] = 33;
  while(nMotorEncoder[motorC] < 60){}
  motor[motorC] = 0;
  wait1Msec(50);

  motor[motorB] =-40;
  motor[motorA] = -40;
  wait1Msec(3000);

  if(ball==2)
  {
   	nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorB] =30;
    motor[motorA] = -30;
    while(nMotorEncoder[motorB] < 1200){}
    while(nMotorEncoder[motorA] > -1200){}
    motor[motorB] = 0;
    motor[motorA] = 0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorA]=-30;
    motor[motorB]=-30;
    while(nMotorEncoder[motorB] > -700){}
    while(nMotorEncoder[motorA] > -700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorC] = 0;
    motor[motorC] = 20;
    while(nMotorEncoder[motorC] < 70){}
    motor[motorC] = 0;
    wait1Msec(1000);

    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorA]=30;
    motor[motorB]=30;
    while(nMotorEncoder[motorB] < 700){}
    while(nMotorEncoder[motorA] < 700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
    nMotorEncoder[motorA] = 0;
    motor[motorB] =-30;
    motor[motorA] = 30;
    while(nMotorEncoder[motorB] > -1200){}
    while(nMotorEncoder[motorA] < 1200){}
    motor[motorB] = 0;
    motor[motorA] = 0;
    wait1Msec(500);
  }


    else if(ball==5)
    {
     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] = -30;
     motor[motorA] = 30;
     while(nMotorEncoder[motorB] > -1250){}
     while(nMotorEncoder[motorA] < 1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=30;
    motor[motorB]=30;
    while(nMotorEncoder[motorB] < 700){}
     while(nMotorEncoder[motorA] < 700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

     nMotorEncoder[motorC] = 0;
     motor[motorC] = 20;
     while(nMotorEncoder[motorC] < 70){}
     motor[motorC] = 0;
     wait1Msec(1000);

     nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorA]=-30;
    motor[motorB]=-30;
    while(nMotorEncoder[motorB] > -700){}
     while(nMotorEncoder[motorA] > -700){}

    motor[motorA]=0;
    motor[motorB]=0;
    wait1Msec(500);

    nMotorEncoder[motorB] = 0;
     nMotorEncoder[motorA] = 0;
     motor[motorB] = 30;
     motor[motorA] = -30;
     while(nMotorEncoder[motorB] < 1250){}
     while(nMotorEncoder[motorA] > -1250){}
     motor[motorB] = 0;
     motor[motorA] = 0;
     wait1Msec(500);
   }

   nMotorEncoder[motorC] = 0;
   motor[motorC] = -20;
   while(nMotorEncoder[motorC] > -100 ){}
   motor[motorC] = 0;
   wait1Msec(1000);
}
